<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/WangZhi.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/WangZhi.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/WangZhi.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/WangZhi.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/WangZhi.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/WangZhi.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/WangZhi.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="IT小白进阶">
<meta property="og:url" content="https://misswanglove.github.io/WangZhi.github.io/index.html">
<meta property="og:site_name" content="IT小白进阶">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IT小白进阶">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/WangZhi.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://misswanglove.github.io/WangZhi.github.io/"/>





  <title>IT小白进阶</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/MissWangLove"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/WangZhi.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IT小白进阶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/WangZhi.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/WangZhi.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/WangZhi.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/WangZhi.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/WangZhi.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/WangZhi.github.io/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/WangZhi.github.io/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/WangZhi.github.io/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            something
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/04/成神之路/02-Java中的内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/04/成神之路/02-Java中的内存模型/" itemprop="url">02 Java中的内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T20:36:50+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/成神之路/" itemprop="url" rel="index">
                    <span itemprop="name">成神之路</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存中取出变量（这的变量包括实例字段。静态字段和构成数组对象的元素）这样的底层细节。 </p>
<p>为了获得较好的执行效能。Java内存模型没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 </p>
<p>Java内存模型规定了所有的变量（前面的变量）都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递都依靠内存完成。线程、主内存、工作内存的关系如图： <img src="F:\desktop\Desktop\markdown\Java\成神之路\image\memory2.jpg" alt="memory2"></p>
<p>主内存和工作内存之间的交互协议（变量拷贝到工作内存，再从工作内存同步回主内存），Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一个操作都是原子性、不可再分的（double和long例外）。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* lock（锁定）:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</span><br><span class="line">* unlock（解锁）:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</span><br><span class="line">* read（读取）:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</span><br><span class="line">* load（载入）:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</span><br><span class="line">* use（使用）:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</span><br><span class="line">* assign（赋值）:作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</span><br><span class="line">* store（存储）:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。</span><br><span class="line">* wirte（写入）:作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。</span><br></pre></td></tr></table></figure>
<p>变量从主内存到工作内存，必须经过read和load，从 工作内存同步回主内存，需要经过store和write操作，这两个操作必须按顺序执行，但不一定是连续执行。也就是在两个操作之间可以有其他的操作。 在使用上面的8中操作的时候需要满足的规则 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 不允许read和load、 store和 write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作存发起回写了但主内存不接受的情况出现。</span><br><span class="line">* 不允许一个线程丢弃它的最近的 assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</span><br><span class="line">* 不允许一个线程无原因地（没有发生过任何 assign操作）把数据从线程的工作内存同步回主内存中。</span><br><span class="line">* 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说，就是对一个变量实施use、 store操作之前必须先执行过了 assign和load操作。</span><br><span class="line">* 一个变量在同一个时刻只允许一条线程其进行1ock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的 unlock操作，变量被解锁。</span><br><span class="line">* 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或 assign操作初始化变量的值。</span><br><span class="line">* 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去 unlock一个被其他线程锁定住的变量。</span><br><span class="line">* 对一个变量执行 unlock操作之前，必须先把此变量同步回主内存中（执行stre、wite操作）。</span><br></pre></td></tr></table></figure>
<p>Java内存模型要求的8个操作都具有原子性，但是对于64位的数据类型（long和double），定义了宽松的规定：允许虚拟机将没有被volitale修饰的64位数据的读写操作划分为两次32位的操作来进行，也就是虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这个就是所谓的long和double的非原子性协定。 </p>
<h4 id="内存模型的介绍"><a href="#内存模型的介绍" class="headerlink" title="内存模型的介绍"></a>内存模型的介绍</h4><h6 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h6><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。编译器和处理器可能会对操作做重排序，但是不会改变存在数据依赖关系的两个操作的执行顺序。遵循as-if-serial语义：即不管程序怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变，但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。 </p>
<h6 id="volatile型变量的规则"><a href="#volatile型变量的规则" class="headerlink" title="volatile型变量的规则"></a>volatile型变量的规则</h6><p>volatile是Java虚拟机提供的最轻量级的同步机制。当一个变量被定义为volatile类型后具备两种特性 ：第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写。 第二是一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 </p>
<p>使用volatile变量的第一个语义是只保证可见性，有些场景下不适用，这个时候仍然需要通过加锁来保证原子性。不符合的运算场景：一是运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。二是变量不需要与其他的状态变量共同参与不变约束。 </p>
<p> 第二个语义是禁止指令重排序优化，前面的重排序优化说过，编译器和处理器为了提高并行度，会对程序进行重排序，不能保证变量赋值的操作顺序与程序代码中的执行顺序一致。在使用volatile之后，在进行对volatile修饰的变量进行赋值后，会多执行一个lock操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问是不需要这个内存屏障的，但是多个CPU 访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性了。 </p>
<p>Java内存模型中对 volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个 volatile型变量，那么在进行read、load、use、 assign store和 write操作时需要满足如下规则: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 只有当线程T对变量V执行的前一个作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用v前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。</span><br><span class="line">* 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、 write动作相关联，必须连续一起出现（这条规则要求在工作内存中每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量v所做的修改）。</span><br><span class="line">* 假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或 store动作，假定动作P是和动作F相应的对变量V的read或 wrte动作；类似的，假定动作B是线程T对变量W实施的use或 assign动作，假定动作是和动作B相关联的load或 store动作，假定动作Q是和动作G相应的对变量WErad或 write a动作。如果A先于B，那么P先于Q（这条规则要求 volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</span><br></pre></td></tr></table></figure>
<h6 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h6><p>Java内存模型来直接保证的原子性变量操作包括read、load、assign， use、 store和 wrte，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和 double的非原子性协定），如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和 unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter和 monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块— synchronized关键字，因此在synchronized块之间的操作也具备原子性。 </p>
<h6 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h6><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。前面说 volatile变量的时候说过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是 volatile变量都是如此，普通变量与volatile变量的区别是， volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。 </p>
<p>除了 volatile之外，Java还有两个关键字能实现可见性，即 synchronized和 final。同步块的可见性是由“对一个变量执行 unlock作之前，必须先把此变量同步回主内存中（执行store、 write操作）”这条规则获得的，而final关键字的可见性是指:被 final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见 final字段的值。 </p>
<h6 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h6><p>Java内存模型的有序性在前面说volatile时也说过了，Java程序中天然的有序性可以总结为一句话:如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（ Within- Thread As-If- Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 </p>
<p>Java语言提供了 volatile和 synchronized 两个关键字来保证线程之间操作的有序性 ，volatile关键字本身就包含了禁止指令重排序的语义，而 synchronized则是由“一个变量在同个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。 </p>
<h6 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h6><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 </p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序 ：</p>
<ul>
<li>程序次序规则（ Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（ Monitor Lock Rule）:一个 unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（ Volatile Variable Rul）:对一个 volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（ Thread Start Rule）: Thread对象的 start（）方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（ Thread Termination Rul）:线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join()方法结束、 Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（ Thread Interruption Rul）:对线程 interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（ Finalizer Rule）:一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize（）方法的开始。</li>
<li>传递性（Transitivity）:如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>在Java程序中，时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/04/成神之路/01-Java中的内存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/04/成神之路/01-Java中的内存结构/" itemprop="url">01 Java中的内存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T20:36:24+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/成神之路/" itemprop="url" rel="index">
                    <span itemprop="name">成神之路</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java中的内存结构"><a href="#Java中的内存结构" class="headerlink" title="Java中的内存结构"></a>Java中的内存结构</h2><h3 id="运行时数据区域的划分："><a href="#运行时数据区域的划分：" class="headerlink" title="运行时数据区域的划分："></a>运行时数据区域的划分：</h3><p><img src="F:\desktop\Desktop\markdown\Java\成神之路\image\memory.jpg" alt="memory"></p>
<h5 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h5><p>程序计数器（Program Counter Register）是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作就是通过改变这个计数器的值来选择下一条执行的字节码指令，分支、跳转、循环、异常处理、线程恢复等基础功能都需要依赖计数器来完成。</p>
<p>Java虚拟机的多线程就是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。为了线程切换后可以恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互相不影响，独立存储，这类区域也称为“私有线程”的内存。</p>
<p>线程执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是本地方法（Native），计数器为空（undefined）。<strong><em>程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</em></strong></p>
<h5 id="Java虚拟机栈（Java方法栈）"><a href="#Java虚拟机栈（Java方法栈）" class="headerlink" title="Java虚拟机栈（Java方法栈）"></a>Java虚拟机栈（Java方法栈）</h5><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame：方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的一个过程。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（byte、short、int、long、float、double、char、boolean）、对象引用（reference类型，它不等同与对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象句柄或其它与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。其中的64位的long和double类型的数据会占用两个局部变量空间，其余数据类型只占用一个。（可以将局部变量表看成一个数组，long和double占用两个数组单元，其余占用一个数组单元，一个数组单元在64位的HotSpot上占用8个字节，32位的HotSpot上占用4个字节，这也意味着在局部变量表，除了long和double，其余的类型所占的空间大小是相同的。但是在堆上存储的字节长度与实际值域相吻合）局部变量表所需的内存空间在编译期间就完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不回改变局部变量表的大小。</p>
<p>两个异常：线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。虚拟机的动态扩展无法申请到足够的内存，会抛出OutOfMemoryError异常。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常类似的，他们之间的区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，二本地方法栈为虚拟机使用到的Navicat方法服务 。</p>
<p>本地方法栈也会抛出SatckOverflowError和OutOfMemoryError。 </p>
<h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，<strong><em>几乎</em></strong>所有的对象实例都在这分配内存。 Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配，但是对着JIT编译器的发挥和逃逸技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么绝对。 </p>
<p>Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆页无法扩展时，将会抛出OutOfMemoryError异常。 </p>
<p>字符串常量池是在堆中存放和实现的。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态常量。即时编译编译后额代码等数据（字节码相关的文件）。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 </p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息。常量池用于存放编译器生成的各种字面量（文本字符串、八种基本类型的值、被声明为final的常量等）和符号引用（类和方法的全限定名、字段的名称和描述符、方法的名称和描述符），当常量池无法申请到内存时会抛出OutOfMemoryError异常。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/02/直面Java/直面Java02-异常汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/02/直面Java/直面Java02-异常汇总/" itemprop="url">直面Java02-异常汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T16:40:51+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/直面Java/" itemprop="url" rel="index">
                    <span itemprop="name">直面Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常相关的总结"><a href="#异常相关的总结" class="headerlink" title="异常相关的总结"></a>异常相关的总结</h2><h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p><img src="F:\desktop\Desktop\markdown\Java\直面Java\image\throwale.jpg" alt="throwale"></p>
<p>Throwable是Java中最顶级的异常类，继承Object，实现序列化接口，有两个重要的子类：Exception和Error，二者都是Java异常处理的重要子类，各自包含了大量子类。</p>
<h5 id="Exception与Error"><a href="#Exception与Error" class="headerlink" title="Exception与Error"></a>Exception与Error</h5><p>Error是系统级的错误，是Java运行环境内部错误或者硬件错误问题，不能指望依靠程序类处理这样的问题，除了退出程序外，别无选择，是由JVM抛出的。</p>
<p>Exception表示程序需要捕捉、需要处理的异常，是由于程序设计不完善而出现的问题，程序必须处理的问题。</p>
<p>二者都是继承Throwable类，在java中只有Throwable类的实例才能被抛出（throw）或者捕获（catch），他是异常机制的基本组成类型。 </p>
<h5 id="Exception的分类"><a href="#Exception的分类" class="headerlink" title="Exception的分类"></a>Exception的分类</h5><p>Exception分为两类，一类是受检异常（编译期异常），一类是非受检异常（运行时异常）。</p>
<p>受检异常是一个方法在生命过程中抛出受检异常，那么在调用这个方法的时候就要对抛出的受检异常进行处理（继续上抛或者捕获处理），否则无法编译通过，这个是一种规范。这种异常在IO操作中是比较多的，比方说FileNotFoundException，意思是文件可能不存在，不存在的话就会抛出异常。当希望方法的调用者明确处理一些特殊情况的时候，就应该使用受检异常。</p>
<p>非受检异常继承自RuntimeException。这种异常不需要显示的进行捕获，在运行期间一旦出现异常就会中断程序的运行。这种异常一般是代码原因导致，比如说空指针异常、数组越界、by/zero等等，都是可以避免的。</p>
<h5 id="处理受检异常"><a href="#处理受检异常" class="headerlink" title="处理受检异常"></a>处理受检异常</h5><p>使用throw制造异常（应该不算是处理异常）。</p>
<p>使用throws抛出异常。</p>
<p>使用try{}catch(){}finally}{}捕获异常。</p>
<p>总的来说，处理异常只有两种方式，抛出和捕获。</p>
<h5 id="捕获异常之后应该做什么？"><a href="#捕获异常之后应该做什么？" class="headerlink" title="捕获异常之后应该做什么？"></a>捕获异常之后应该做什么？</h5><p>常见的处理方法：记录日志、封装异常重新抛出、忽略、正常返回。最不可取的处理方法是忽略，最好的是伴随日志记录，把异常信息记录下来。</p>
<h5 id="异常处理的关键字"><a href="#异常处理的关键字" class="headerlink" title="异常处理的关键字"></a>异常处理的关键字</h5><p>throws、throw、try、catch、finally是异常处理的关键字。</p>
<p>try是指定一块预防所有异常的程序。catch子句是紧跟try块后面，用来制定你想要捕获的异常类型。finally是为了确保一段代码不管发生什么异常状况都要执行。throw语句是用来明确地抛出一个异常。throws是用来声明一个方法可能抛出的各种异常。</p>
<h5 id="finally语句与return"><a href="#finally语句与return" class="headerlink" title="finally语句与return"></a>finally语句与return</h5><p>finally语句被执行的前提条件是对应try语句块被执行并程序正常运行，正常运行的意思是JVM没有退出或者线程没有被killed、interrupted。</p>
<p>try-catch-finally与return语句的关系。try与catch语句块中有语句：return a + b; 则finally语句块会在a + b之后执行，return 之前执行，也就是<strong>返回前，操作后</strong>执行。</p>
<p>如果finally 中有 return ，那将结果直接返回，在 try 或 catch 中也有 return a，会将 a 的值压栈，再弹出保存到变量表,最终返回新生成的 a 值。 因此在 finally 中操作原来的 a 值对结果没有影响，如果 a 是引用就有影响。 简单说finally中操作的变量不会影响try中的数据，但是不要操作引用数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(method()); // 返回的值是0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  int method()&#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 10;</span><br><span class="line">        try &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="finally语句一定会执行？"><a href="#finally语句一定会执行？" class="headerlink" title="finally语句一定会执行？"></a>finally语句一定会执行？</h5><p>不一定，前面说过finally会执行的两个前提条件，必须满足才可以执行。比方说在try或者catch块中使用System.exit(0)语句是的JVM中断，这个时候finally语句就不会被执行。</p>
<h5 id="异常链的介绍"><a href="#异常链的介绍" class="headerlink" title="异常链的介绍"></a>异常链的介绍</h5><p>“异常链”是Java中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。该技术大多用于将“ 受检查异常” （ checked exception）封装成为“非受检查异常”（unchecked exception)或者RuntimeException。顺便说一下，如果因为异常你决定抛出一个新的异常，你一定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()方法来访问异常最终的根源。 </p>
<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>自定义异常就是开发人员自己定义的异常，一般通过继承Exception的子类的方式实现。  编写自定义异常类实际上是继承一个API标准异常类，用新定义的异常处理信息覆盖原有信息的过程。  这种用法在Web开发中也比较常见，一般可以用来自定义也无异常。如余额不足、重复提交等。这种自定义异常有业务含义，更容易让上层理解和处理。 </p>
<h5 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h5><p>这个是Java7中新出的，下面比较一下JDK7之前和之后的异常捕获，以IO流来举例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.wzlove.demo;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 标准的IO格式处理</span><br><span class="line"> *</span><br><span class="line"> * @author WZLOVE</span><br><span class="line"> * @create 2018-07-23 9:54</span><br><span class="line"> */</span><br><span class="line">public class StandardIO &#123;</span><br><span class="line"></span><br><span class="line">    // jdk7之前</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 初始赋值为null</span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        FileWriter fw = null;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 创建字符流对象</span><br><span class="line">            fr = new FileReader(&quot;student.txt&quot;);</span><br><span class="line">            fw = new FileWriter(&quot;student.txt&quot;);</span><br><span class="line"></span><br><span class="line">            // 操作资源(边读编写,耗资源,仅作为示例)</span><br><span class="line">            int len;</span><br><span class="line">            while((len = fr.read()) != -1)&#123;</span><br><span class="line">                fw.write((char) len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 判断输入流是否为null</span><br><span class="line">                if(fr != null)&#123;</span><br><span class="line">                    // 关闭资源</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 判断输入流是否为null</span><br><span class="line">                    if(fw != null) &#123;</span><br><span class="line">                        // 关闭资源</span><br><span class="line">                        fw.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // jdk7之后</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * try(创建IO流对象的代码)&#123;</span><br><span class="line">     *     其他代码</span><br><span class="line">     * &#125;catch(可能出现的异常)&#123;</span><br><span class="line">     *      打印异常信息</span><br><span class="line">     * &#125;</span><br><span class="line">     * 上面的代码会自动调用close方法(也就是IO流对象都实现了Closeable接口(Closeable实现了AutoCloseable接口),</span><br><span class="line">     * 重写close方法).有兴趣的可以查看源码</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">                // 创建字符流对象</span><br><span class="line">                FileReader fr = new FileReader(&quot;student.txt&quot;);</span><br><span class="line">                FileWriter fw = new FileWriter(&quot;student.txt&quot;);</span><br><span class="line">                )&#123;</span><br><span class="line">                         // 操作资源(边读编写,耗资源,仅作为示例)</span><br><span class="line">                int len;</span><br><span class="line">                while((len = fr.read()) != -1)&#123;</span><br><span class="line">                    fw.write((char) len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7之后更新的优化还有Multi-Catch Exceptions、Rethrowing Exceptions、Suppressed Exceptions（<a href="http://www.oracle.com/technetwork/articles/java/java7exceptions-486908.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/articles/java/java7exceptions-486908.html</a>） </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/02/直面Java/直面Java01-AIO-NIO-BIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/02/直面Java/直面Java01-AIO-NIO-BIO/" itemprop="url">直面Java01-AIO-NIO-BIO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T16:39:31+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/直面Java/" itemprop="url" rel="index">
                    <span itemprop="name">直面Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><em>Hollis知识星球的一些学习笔记,有兴趣的朋友可以微信搜一下</em></strong></p>
<h2 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h2><p>什么是IO? 它是指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。  在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。 </p>
<p>什么是NIO? NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。  面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。  一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 </p>
<h2 id="什么是AIO"><a href="#什么是AIO" class="headerlink" title="什么是AIO"></a>什么是AIO</h2><p>Java AIO即Async非阻塞，是异步非阻塞的IO。 </p>
<h2 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO"></a>什么是BIO</h2><p>Java BIO即Block I/O ， 同步并阻塞的IO。  BIO就是传统的java.io包下面的代码实现。 </p>
<h2 id="AIO-BIO-NIO的联系和区别"><a href="#AIO-BIO-NIO的联系和区别" class="headerlink" title="AIO,BIO,NIO的联系和区别"></a>AIO,BIO,NIO的联系和区别</h2><p>BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。 </p>
<p>NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。   </p>
<p>AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。 </p>
<h2 id="BIO实现文件读写"><a href="#BIO实现文件读写" class="headerlink" title="BIO实现文件读写"></a>BIO实现文件读写</h2><p>直接代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.wzlove.bio;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 王智</span><br><span class="line"> * @date 2018/7/31</span><br><span class="line"> * @描述 用户实体类</span><br><span class="line"> */</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7521946815608679573L;</span><br><span class="line">    private  String name;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.wzlove.bio;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 王智</span><br><span class="line"> * @date 2018/7/31</span><br><span class="line"> * @描述 用来测试BIO</span><br><span class="line"> * BIO : Java BIO即Block I/O ， 同步并阻塞的IO。 测试BIO</span><br><span class="line"> * 其实BIO 也就是我们时常说的序列化流和反序列化流</span><br><span class="line"> */</span><br><span class="line">public class BIODemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        // 使用输出流进行写入到文件中</span><br><span class="line">        User user = new User(&quot;王智&quot;,23);</span><br><span class="line">        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;test.txt&quot;))) &#123;</span><br><span class="line">            // 写入</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用输入流进行读取</span><br><span class="line">        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;test.txt&quot;))) &#123;</span><br><span class="line">            // 进行信息的读取</span><br><span class="line">            User user1 = (User)ois.readObject();</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是,写入的读取的对象必须实现Serializable接口,生成serialVersionUID,还有无参构造,都要存在.</p>
</blockquote>
<h2 id="NIO实现文件的读写"><a href="#NIO实现文件的读写" class="headerlink" title="NIO实现文件的读写"></a>NIO实现文件的读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.wzlove.nio;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 王智</span><br><span class="line"> * @date 2018/7/31</span><br><span class="line"> * @描述 NIO 以块的方式处理数据</span><br><span class="line"> * 使用的方法有:</span><br><span class="line"> *    ByteBuffer的常用方法:</span><br><span class="line">     *   static ByteBuffer allocate(int capacity) 分配一个新的字节缓冲区。</span><br><span class="line">     *   int capacity() 返回此缓冲区的容量。</span><br><span class="line">     * 	 int position() 返回此缓冲区的位置。</span><br><span class="line">     * 	 int read(ByteBuffer dst) 从该通道读取到给定缓冲区的字节序列。</span><br><span class="line"> *    Charset的常用方法:</span><br><span class="line">     * 	  Charset forName(String charsetName) 返回名为charset的charset对象。</span><br><span class="line">     * 	  ByteBuffer encode(String str) 在此字符集中将字符串编码为字节的便捷方法。</span><br><span class="line"> */</span><br><span class="line">public class NIODemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        writeNIO();</span><br><span class="line">        System.out.println(&quot;===========================================/&quot;);</span><br><span class="line">        readNIO();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 步骤 :</span><br><span class="line">     *  1.使用输入流创建文件通道</span><br><span class="line">     *  2. 创建字节缓冲区</span><br><span class="line">     *  3. 开始读取内容</span><br><span class="line">     *  4. 将读取的内容转化为字节数组,使用System.out的write方法输出</span><br><span class="line">     */</span><br><span class="line">    public static void readNIO()&#123;</span><br><span class="line">        try (</span><br><span class="line">                // c创建文件通道</span><br><span class="line">                FileChannel fc = new FileInputStream(&quot;nio.txt&quot;).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">            // 创建字节缓冲区(static ByteBuffer allocate(int capacity)分配一个新的字节缓冲区。指定缓冲区的大小  )</span><br><span class="line">            ByteBuffer bb = ByteBuffer.allocate(100);</span><br><span class="line">            // 输出缓冲区的大小</span><br><span class="line">            System.out.println(&quot;输入缓冲区的大小为 : &quot; + bb.capacity());</span><br><span class="line">            // 输出缓冲区的限制大小</span><br><span class="line">            System.out.println(&quot;输入缓冲区的限制大小为 : &quot;  + bb.limit());</span><br><span class="line">            // 输出缓冲区的位置</span><br><span class="line">            System.out.println(&quot;输入缓冲区的位置 : &quot; + bb.position());</span><br><span class="line">            // 进行文件的读取</span><br><span class="line">            int length = -1;</span><br><span class="line">            while((length = fc.read(bb)) != -1)&#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 注意，读取后，将位置置为0，将limit置为容量, 以备下次读入到字节缓冲中，从0开始存储</span><br><span class="line">                 */</span><br><span class="line">                bb.clear();</span><br><span class="line">                byte[] bytes = bb.array();</span><br><span class="line">                System.out.write(bytes,0,length);</span><br><span class="line">                System.out.println();</span><br><span class="line">                // 输出缓冲区的大小</span><br><span class="line">                System.out.println(&quot;输入缓冲区的大小为 : &quot; + bb.capacity());</span><br><span class="line">                // 输出缓冲区的限制大小</span><br><span class="line">                System.out.println(&quot;输入缓冲区的限制大小为 : &quot;  + bb.limit());</span><br><span class="line">                // 输出缓冲区的位置</span><br><span class="line">                System.out.println(&quot;输入缓冲区的位置 : &quot; + bb.position());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 步骤:</span><br><span class="line">     *  1. 使用输出流创建文件通道</span><br><span class="line">     *  2. 创建字节缓冲区</span><br><span class="line">     *  3. 开始进行写入</span><br><span class="line">     */</span><br><span class="line">    public static void writeNIO()&#123;</span><br><span class="line"></span><br><span class="line">        try (</span><br><span class="line">                // 创建FileChannel通道(使用try-with-resouce的形式)</span><br><span class="line">                FileChannel fc = new FileOutputStream(&quot;nio.txt&quot;).getChannel()</span><br><span class="line"></span><br><span class="line">        ) &#123;</span><br><span class="line">            // 按照指定的编码和内容创建字节缓冲区</span><br><span class="line">            ByteBuffer  bb = Charset.forName(&quot;UTF-8&quot;).encode(&quot;你好啊,世界,我爱你,世界&quot;);</span><br><span class="line">            // 输出初始化容量</span><br><span class="line">            System.out.println(&quot;初始化容量 : &quot; + bb.capacity());</span><br><span class="line">            // 输出缓冲区的限制大小</span><br><span class="line">            System.out.println(&quot;缓冲区的限制为 : &quot; + bb.limit());</span><br><span class="line">            int len = 0;</span><br><span class="line">            // 标准的写入文件的代码</span><br><span class="line">            while((len = fc.write(bb)) != 0)&#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 注意，这里不需要clear，将缓冲中的数据写入到通道中后 第二次接着上一次的顺序往下读</span><br><span class="line">                 */</span><br><span class="line">                System.out.println(&quot;写入的长度为 : &quot; + len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AIO实现文件的读写-不是特别理解"><a href="#AIO实现文件的读写-不是特别理解" class="headerlink" title="AIO实现文件的读写(不是特别理解)"></a>AIO实现文件的读写(不是特别理解)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public class AioWrite &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // AsynchronousFileChannel用于读取，写入和操作文件的异步通道。当通过调用此类定义的open方法之一来打开文件时，将创建异步文件通道。</span><br><span class="line">        // static AsynchronousFileChannel open(Path file, OpenOption... options) 打开或创建用于读取和/或写入的文件，返回异步文件通道以访问该文件。</span><br><span class="line">        /*</span><br><span class="line">        StandardOpenOption枚举类:</span><br><span class="line">            APPEND 如果文件打开 WRITE访问，则字节将被写入文件的末尾而不是开头。</span><br><span class="line">            CREATE  创建一个新文件（如果不存在）。</span><br><span class="line">            CREATE_NEW 创建一个新的文件，如果该文件已经存在失败。</span><br><span class="line">            DELETE_ON_CLOSE 关闭时删除。</span><br><span class="line">            DSYNC 要求将文件内容的每次更新都与底层存储设备同步写入。</span><br><span class="line">            READ 打开阅读权限。</span><br><span class="line">            SPARSE 稀疏文件</span><br><span class="line">            SYNC 要求将文件内容或元数据的每次更新都同步写入底层存储设备。</span><br><span class="line">            TRUNCATE_EXISTING 如果文件已经存在，并且打开 WRITE访问，则其长度将截断为0。</span><br><span class="line">            WRITE 打开以进行写入。</span><br><span class="line">         */</span><br><span class="line">        AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(</span><br><span class="line">                Paths.get(&quot;asynchronous.txt&quot;), StandardOpenOption.READ,</span><br><span class="line">                StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">        /*</span><br><span class="line">            CompletionHandler 用于消除异步I / O操作结果的处理程序。</span><br><span class="line">            在此包中定义的异步通道允许指定完成处理程序以消耗异步操作的结果。 当I / O操作成功完成时，</span><br><span class="line">            将调用completed方法。 如果I / O操作失败，则调用failed方法。 这些方法的实现应该及时完成，</span><br><span class="line">            以避免将调用线程调度到其他完成处理程序。</span><br><span class="line">        */</span><br><span class="line">        CompletionHandler&lt;Integer, Object&gt; handler = new CompletionHandler&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void completed(Integer result, Object attachment) &#123;</span><br><span class="line">                System.out.println(&quot;Attachment: &quot; + attachment + &quot; &quot; + result</span><br><span class="line">                        + &quot; bytes written&quot;);</span><br><span class="line">                System.out.println(&quot;CompletionHandler Thread ID: &quot;</span><br><span class="line">                        + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable e, Object attachment) &#123;</span><br><span class="line">                System.err.println(&quot;Attachment: &quot; + attachment + &quot; failed with:&quot;);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Main Thread ID: &quot; + Thread.currentThread().getId());</span><br><span class="line">        // abstract &lt;A&gt; void write(ByteBuffer src, long position, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler)</span><br><span class="line">        // 从给定的缓冲区向给定的文件位置开始，向该通道写入一个字节序列。</span><br><span class="line">        // static ByteBuffer wrap(byte[] array) 将一个字节数组包装到缓冲区中。</span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(&quot;Sample&quot;.getBytes()), 0, &quot;First Write&quot;,</span><br><span class="line">                handler);</span><br><span class="line">        // 第一次写入Sample,第二次写入也是从索引0位置开始的,所以讲Sam覆盖掉了,变为Box,所以结果为Boxple</span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(&quot;Box&quot;.getBytes()), 0, &quot;Second Write&quot;,</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AioReader &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // Path可用于在文件系统中定位文件的对象。 它通常表示系统相关的文件路径</span><br><span class="line">        Path file = Paths.get(&quot;asynchronous.txt&quot;);</span><br><span class="line">        // AsynchronousFileChannel是用于读取，写入和操作文件的异步通道。</span><br><span class="line">        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);</span><br><span class="line">        // 创建字节缓冲区,指定缓冲区的大小</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(100_000);</span><br><span class="line">        // Future接口,A Future计算的结果。 提供方法来检查计算是否完成，等待其完成，并检索计算结果</span><br><span class="line">        Future&lt;Integer&gt; result = channel.read(buffer, 0);</span><br><span class="line">        // boolean isDone() 返回 true如果任务已完成</span><br><span class="line">        while (!result.isDone()) &#123;</span><br><span class="line">            // 暂时不了解</span><br><span class="line">            ProfitCalculator.calculateTax();</span><br><span class="line">        &#125;</span><br><span class="line">        // V get() 等待计算完成，然后检索其结果。</span><br><span class="line">        Integer bytesRead = result.get();</span><br><span class="line">        // 输出文件内容的字节长度</span><br><span class="line">        System.out.println(&quot;Bytes read [&quot; + bytesRead + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProfitCalculator &#123;</span><br><span class="line">    public ProfitCalculator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void calculateTax() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BIO-NIO-AIO适用的场景"><a href="#BIO-NIO-AIO适用的场景" class="headerlink" title="BIO,NIO,AIO适用的场景"></a>BIO,NIO,AIO适用的场景</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/01/Java学习笔记/02-Java的基本数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/01/Java学习笔记/02-Java的基本数据类型/" itemprop="url">day02_Java的基本数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T20:21:29+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本数据类型的加载和存储"><a href="#基本数据类型的加载和存储" class="headerlink" title="基本数据类型的加载和存储"></a>基本数据类型的加载和存储</h2><h3 id="虚拟机中的Boolean类型"><a href="#虚拟机中的Boolean类型" class="headerlink" title="虚拟机中的Boolean类型"></a>虚拟机中的Boolean类型</h3><p>在Java语言规范中,boolean类型的值只有两种可能,那就是”true”和”false”. 但是这两个符号是不能被Java虚拟机直接使用的.</p>
<p>在Java虚拟机规范中,boolean类型则被映射成int类型. 也就是说,”true”被映射为整数1,”false”被映射为整数0.这个编码规则约束了Java字节码的具体实现.</p>
<h3 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h3><p>Java中的基本类型有8个,上面的boolean类型, 整数类型的byte、short、char、int和 long，以及浮点类型 float 和 double.</p>
<p><img src="./image/java01.jpg" alt="基本数据类型"></p>
<p>java的基本类型都有对应的值域和默认值,如图,从上到下的值域一次增大,后面的值域包含前面的值域,意味着上面的数据类型转换为下面的数据类型不需要进行强制转换。还有注意默认值看起来不一样，实际在内存中都是0。</p>
<p>8个基本数据类型中，只有char和boolean是无符号数。并且boolean类型的取值范围为0或者1，char类型的取值范围为[0,65535]。通常我们认为char类型的值为非负数。</p>
<p>Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存</p>
<p>数值不同，但是在 Java 中 +0.0F == -0.0F 会返回真。</p>
<p>有了+0.0F和-0.0F后，那么浮点数中的正无穷和负无穷就可以定义了。正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F得到的值。在 Java 中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数0x7F800000 和 0xFF800000。</p>
<p>那超出范围的数字呢？ 对应的是NaN（Not-a-Number）,0x7FC00000为标准的NaN，其他的称之为不标准的NaN。并且NaN有一个特性，任何数 ！= NaN 永远返回true。</p>
<h3 id="Java基本类型的大小"><a href="#Java基本类型的大小" class="headerlink" title="Java基本类型的大小"></a>Java基本类型的大小</h3><h5 id="存储时的大小"><a href="#存储时的大小" class="headerlink" title="存储时的大小"></a>存储时的大小</h5><p>Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。暂时理解为解释器使用的解释栈帧。包括两个组成部分，局部变量区和字节码操作数栈。</p>
<p>在Java虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数索引。除了long、double值需要用两个数组单元来存储之外，其他的基本类型以及引用类型的值均占用一个数组单元。</p>
<p>也就是说，boolean、byte、char、short这四种类型，在栈上占用的空间和int是一样的，和引用类型也是一样的。也就是32位的HotSpot上，栈上占用4个字节；64位的HotSpot上，占用8个字节。</p>
<p>当然，这种情况仅存在于局部变量，而并不会出现在存储于堆上的字段和数组元素伤。对于byte、char以及short这三种类型的字段或者数组单元，他们在堆上占用的空间分别为一字节、两字节以及两字节，与值域是相吻合的。</p>
<p>因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由</p>
<p>于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。</p>
<p>boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入boolean 字段或数组中。</p>
<h5 id="加载时的大小"><a href="#加载时的大小" class="headerlink" title="加载时的大小"></a>加载时的大小</h5><p>Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。</p>
<p>对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。</p>
<p>对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最</p>
<p>高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。</p>
<p>除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑+0.0F、-0.0F 以及 NaN 的情况。</p>
<p>除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或</p>
<p>者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。</p>
<h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>从这个中，可以学到，8种基本数据的大小，还有虚拟机对于基本数据类型的规范是什么，堆上和解释执行的方法栈帧上的byte、short、char、boolean类型的存储的大小是不一样的，加载（读取）的时候，会进行掩码的操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/08/01/深入理解Java虚拟机/02-Java的基本数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/08/01/深入理解Java虚拟机/02-Java的基本数据类型/" itemprop="url">day02_Java的基本数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T20:21:29+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本数据类型的加载和存储"><a href="#基本数据类型的加载和存储" class="headerlink" title="基本数据类型的加载和存储"></a>基本数据类型的加载和存储</h2><h3 id="虚拟机中的Boolean类型"><a href="#虚拟机中的Boolean类型" class="headerlink" title="虚拟机中的Boolean类型"></a>虚拟机中的Boolean类型</h3><p>在Java语言规范中,boolean类型的值只有两种可能,那就是”true”和”false”. 但是这两个符号是不能被Java虚拟机直接使用的.</p>
<p>在Java虚拟机规范中,boolean类型则被映射成int类型. 也就是说,”true”被映射为整数1,”false”被映射为整数0.这个编码规则约束了Java字节码的具体实现.</p>
<h3 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h3><p>Java中的基本类型有8个,上面的boolean类型, 整数类型的byte、short、char、int和 long，以及浮点类型 float 和 double.</p>
<p><img src="./image/java01.jpg" alt="基本数据类型"></p>
<p>java的基本类型都有对应的值域和默认值,如图,从上到下的值域一次增大,后面的值域包含前面的值域,意味着上面的数据类型转换为下面的数据类型不需要进行强制转换。还有注意默认值看起来不一样，实际在内存中都是0。</p>
<p>8个基本数据类型中，只有char和boolean是无符号数。并且boolean类型的取值范围为0或者1，char类型的取值范围为[0,65535]。通常我们认为char类型的值为非负数。</p>
<p>Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存</p>
<p>数值不同，但是在 Java 中 +0.0F == -0.0F 会返回真。</p>
<p>有了+0.0F和-0.0F后，那么浮点数中的正无穷和负无穷就可以定义了。正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F得到的值。在 Java 中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数0x7F800000 和 0xFF800000。</p>
<p>那超出范围的数字呢？ 对应的是NaN（Not-a-Number）,0x7FC00000为标准的NaN，其他的称之为不标准的NaN。并且NaN有一个特性，任何数 ！= NaN 永远返回true。</p>
<h3 id="Java基本类型的大小"><a href="#Java基本类型的大小" class="headerlink" title="Java基本类型的大小"></a>Java基本类型的大小</h3><h5 id="存储时的大小"><a href="#存储时的大小" class="headerlink" title="存储时的大小"></a>存储时的大小</h5><p>Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。暂时理解为解释器使用的解释栈帧。包括两个组成部分，局部变量区和字节码操作数栈。</p>
<p>在Java虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数索引。除了long、double值需要用两个数组单元来存储之外，其他的基本类型以及引用类型的值均占用一个数组单元。</p>
<p>也就是说，boolean、byte、char、short这四种类型，在栈上占用的空间和int是一样的，和引用类型也是一样的。也就是32位的HotSpot上，栈上占用4个字节；64位的HotSpot上，占用8个字节。</p>
<p>当然，这种情况仅存在于局部变量，而并不会出现在存储于堆上的字段和数组元素伤。对于byte、char以及short这三种类型的字段或者数组单元，他们在堆上占用的空间分别为一字节、两字节以及两字节，与值域是相吻合的。</p>
<p>因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由</p>
<p>于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。</p>
<p>boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入boolean 字段或数组中。</p>
<h5 id="加载时的大小"><a href="#加载时的大小" class="headerlink" title="加载时的大小"></a>加载时的大小</h5><p>Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。</p>
<p>对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。</p>
<p>对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最</p>
<p>高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。</p>
<p>除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑+0.0F、-0.0F 以及 NaN 的情况。</p>
<p>除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或</p>
<p>者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。</p>
<h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>从这个中，可以学到，8种基本数据的大小，还有虚拟机对于基本数据类型的规范是什么，堆上和解释执行的方法栈帧上的byte、short、char、boolean类型的存储的大小是不一样的，加载（读取）的时候，会进行掩码的操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/07/31/Java学习笔记/day14-reflect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/07/31/Java学习笔记/day14-reflect/" itemprop="url">day14-reflect</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T19:06:36+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Junit-反射"><a href="#Junit-反射" class="headerlink" title="Junit,反射"></a>Junit,反射</h1><h2 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h2><p>1.测试的分类:</p>
<ul>
<li>黑盒测试 : 不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li>白盒测试 : 需要进行代码的编写,关注的是程序的具体流程.</li>
</ul>
<p>2.使用步骤(方法类的命名可以参考阿里巴巴开发手册):</p>
<pre><code>* 步骤：
    1. 定义一个测试类(测试用例)
        * 建议：
            * 测试类名：被测试的类名Test        
            * 包名：xxx.xxx.xx.test        

    2. 定义测试方法：可以独立运行
        * 建议：
            * 方法名：test测试的方法名        testAdd()  
            * 返回值：void
            * 参数列表：空参

    3. 给方法加@Test
    4. 导入junit依赖环境

* 判定结果：
    * 红色：失败
    * 绿色：成功
    * 一般我们会使用断言操作来处理结果
        * Assert.assertEquals(期望的结果,运算的结果);

* 补充：
    * @Before:
        * 修饰的方法会在测试方法之前被自动执行
    * @After:
        * 修饰的方法会在测试方法执行之后自动被执行


// 举个例子
public class Calculator {

    /**
     * 加法运算
     * @param a  加数
     * @param b  被加数
     * @return   和
     */
    public int add(int a,int b){
        return a + b;
    }

    /**
     * 减法运算
     * @param a  减数
     * @param b  被减数
     * @return   差值
     */
    public int sub(int a,int b){
        return a - b;
    }
}

// 测试类的创建
package com.wzlove.test;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

/**
 * @author 王智
 * @date 2018/7/31
 * @描述 测试类
 */

public class CalculatorTest {

    Calculator cal;

    /**
     * 初始化
     */
    @Before
    public void init(){
        // 初始化对象
        cal = new Calculator();
        System.out.println(&quot;init==================================================&quot;);
    }

    /**
     * 测试加法运算
     */
    @Test
    public void testAdd(){
        // 调用方法
        int result = cal.add(10, 10);
        // 断言
        Assert.assertEquals(20,result);
    }

    /**
     * 测试减法运算
     */
    @Test
    public void testSub(){
        // 调用方法
        int result = cal.sub(10, 10);
        // 断言
        Assert.assertEquals(0,result);
    }

    @After
    public void end(){
        System.out.printf(&quot;end========================================&quot;);
    }   
}
</code></pre><h2 id="反射-框架的设计灵魂"><a href="#反射-框架的设计灵魂" class="headerlink" title="反射 : 框架的设计灵魂"></a>反射 : 框架的设计灵魂</h2><ul>
<li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li>
<li>反射：将类的各个组成部分封装为其他对象，这就是反射机制<ul>
<li>好处：<ol>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
</ol>
</li>
</ul>
</li>
<li><p>获取Class对象的方式：</p>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul>
<li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>
</ul>
</li>
<li>类名.class：通过类名的属性class获取<ul>
<li>多用于参数的传递</li>
</ul>
</li>
<li>对象.getClass()：getClass()方法在Object类中定义着。<ul>
<li>多用于对象的获取字节码的方式</li>
</ul>
</li>
</ol>
<ul>
<li>结论：<br>  同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li>
</ul>
</li>
</ul>
<pre><code>package com.wzlove.reflect;

    /**
     * @author 王智
     * @date 2018/7/31
     * @描述  获取字节码对象的三种方式
     */
    public class GetClassObject {

        public static void main(String[] args) throws Exception {
            // 第一种: 使用全类名进行获取
            Class&lt;?&gt; aClass = Class.forName(&quot;com.wzlove.reflect.GetClassObject&quot;);
            System.out.println(aClass);
            // 第二种: 使用类名的属性获取
            Class aClass1 = GetClassObject.class;
            System.out.println(aClass1);
            // 第三种: 使用类的方法进行获取
            Class&lt;?&gt; aClass2 = new GetClassObject().getClass();
            System.out.println(aClass2);

            System.out.println(aClass == aClass1);
            System.out.println(aClass == aClass2);
        }
    }
</code></pre><ul>
<li>Class对象功能：<ul>
<li>获取功能：</li>
</ul>
</li>
</ul>
<pre><code>1. 获取成员变量们
    * Field[] getFields() ：获取所有public修饰的成员变量
    * Field getField(String name)   获取指定名称的 public修饰的成员变量

    * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
    * Field getDeclaredField(String name)  
2. 获取构造方法们
    * Constructor&lt;?&gt;[] getConstructors()  
    * Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)  

    * Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)  
    * Constructor&lt;?&gt;[] getDeclaredConstructors()  
3. 获取成员方法们：
    * Method[] getMethods()  
    * Method getMethod(String name, Class&lt;?&gt;... parameterTypes)  

    * Method[] getDeclaredMethods()  
    * Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)  

4. 获取全类名    
    * String getName()  
</code></pre><ul>
<li><p>Field：成员变量</p>
<ul>
<li><p>操作：</p>
<ol>
<li>设置值<ul>
<li>void set(Object obj, Object value)  </li>
</ul>
</li>
<li><p>获取值</p>
<ul>
<li>get(Object obj) </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<ul>
<li>setAccessible(true):暴力反射</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>// 下面的例子全部使用Student类
    package com.wzlove.reflect;

    /**
     * @author 王智
     * @date 2018/7/31
     * @描述
     */
    public class Student {

        private String name;

        private int age;

        public String sex;

        @Override
        public String toString() {
            return &quot;Student{&quot; +
                    &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                    &quot;, age=&quot; + age +
                    &quot;, sex=&apos;&quot; + sex + &apos;\&apos;&apos; +
                    &apos;}&apos;;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public String getSex() {
            return sex;
        }

        public void setSex(String sex) {
            this.sex = sex;
        }

        public Student(String name, int age, String sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }

        public Student() {
        }
    }


    package com.wzlove.reflect;

    import java.lang.reflect.Field;

    /**
     * @author 王智
     * @date 2018/7/31
     * @描述 利用反射获取对象的成员变量
     */
    public class GetFieldDemo {

        public static void main(String[] args) throws Exception {
            // 利用反射获取公有成员变量的步骤
            // 1. 获取反射对象(3种方法)
            Class aClass = Student.class;
            // 2. 获取成员变量
            Field sex =  aClass.getField(&quot;sex&quot;);
            // 3. 使用Field的方法设置值(需要创建对象)
            Student stu = new Student();
            sex.set(stu,&quot;男&quot;);
            // 4. 使用Field的方法获取值
            System.out.println(sex.get(stu));



            // 获取所有成员变量
            // 1. 获取反射对象(3种方法)
            Class aClass1 = Student.class;
            // 2. 获取成员变量
            Field name =  aClass1.getDeclaredField(&quot;name&quot;);
            // 3. 使用Field的方法设置值(需要创建对象)
            Student stu1 = new Student();
            // 4. 再使用私有变量的时候会报错,所以要跳过检测,也成为暴力反射
            name.setAccessible(true);
            name.set(stu1,&quot;王智&quot;);
            // 6. 使用Field的方法获取值
            System.out.println(name.get(stu1));
        }

    }
</code></pre><ul>
<li><p>Constructor:构造方法</p>
<ul>
<li><p>创建对象：</p>
<ol>
<li><p>T newInstance(Object… initargs)  </p>
</li>
<li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>package com.wzlove.reflect;

    import java.lang.reflect.Constructor;

    /**
     * @author
     * @date 2018/7/31
     * @描述 利用反射获取对象的构造方法
     */
    public class GetConstructDemo {

        public static void main(String[] args) throws Exception {
            // 利用反射获取公有成员变量的步骤
            // 1. 获取反射对象(3种方法)
            Class aClass = Student.class;
            // 2. 使用方法获取构造方法的对象
            Constructor constructor = aClass.getConstructor(String.class, int.class, String.class);
            // 3. 使用Constructor对象初始化对象
            Object obj = constructor.newInstance(&quot;张三&quot;, 23, &quot;男&quot;);
            // 测试输出结果
            System.out.println(obj);
            System.out.println(&quot;===================================&quot;);

            // 无参构造的方法
            // 1. 获取反射对象(3种方法)
            Class aClass1 = Student.class;
            // 2. 使用方法获取构造方法的对象
            Constructor constructor1 = aClass1.getConstructor();
            // 3. 使用Constructor初始化对象
            Object obj1 = constructor1.newInstance();
            // 测试输出结果
            System.out.println(obj1);

            // 还有个简化写法,仅仅适用于无参构造,但是我使用JDK10已经不推荐使用了
            Object obj2 = aClass1.newInstance();
            System.out.println(obj2);

            // getDeclaredConstructor方法也是获取私有的构造方法,就不演示了
        }

    }
</code></pre><ul>
<li><p>Method：方法对象</p>
<ul>
<li><p>执行方法：</p>
<ul>
<li>Object invoke(Object obj, Object… args)  </li>
</ul>
</li>
<li><p>获取方法名称：</p>
<ul>
<li>String getName:获取方法名    </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>首先在Student中添加两个方法  </p>
<pre><code>public void eat(){
    System.out.println(&quot;eat..............&quot;);
}

public int add(int a, int b){
   return a + b;
}

package com.wzlove.reflect;

import java.lang.reflect.Method;

/**
 * @author 王智
 * @date 2018/7/31
 * @描述 反射执行方法
 */
public class GetMethodDemo {

    public static void main(String[] args) throws Exception {
        // 无参无返回值的方法
        // 1. 创建字节码对象
        Class aClass = Student.class;
        // 2. 创建方法的对象
        Method eat = aClass.getMethod(&quot;eat&quot;);
        // 3. 执行方法
        Student stu = new Student();
        eat.invoke(stu);

        // 有参有返回值的方法
        // 1. 创建字节码对象
        Class aClass1 = Student.class;
        // 2. 创建方法的对象
        Method add = aClass1.getMethod(&quot;add&quot;, int.class,int.class);
        // 3. 执行方法
        Student stu1 = new Student();
        Object sum = add.invoke(stu1, 10, 10);
        System.out.println(&quot;和为&quot; + sum);
        System.out.println(&quot;======================================================&quot;);
        // 获取该类所有的方法(这里获取的不仅仅是自己定义的方法,还有从父类继承来的方法)
        Method[] methods = aClass1.getMethods();
        for (Method method : methods) {
            System.out.println(method);
            System.out.println(method.getName());
        }
        System.out.println(&quot;======================================================&quot;);

        // 获取类名
        System.out.println(aClass1.getName());
        // getDeclaredMethod也是同样的道理
    }
}
</code></pre><p>以上就是反射的简单使用了.举个简单例子,当然这个例子并不完善,将就看</p>
<pre><code>package com.wzlove.reflect;


import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * @author 
 * @date 2018/7/31
 * @描述
 * * 案例：
 *     * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，
 *     并且执行其中任意方法
 *         * 实现：
 *             1. 配置文件
 *             2. 反射
 *         * 步骤：
 *             1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
 *             2. 在程序中加载读取配置文件
 *             3. 使用反射技术来加载类文件进内存
 *             4. 创建对象
 *             5. 执行方法
 */
public class ReflectDemo {

    public static void main(String[] args) throws Exception {
        // 创建本类的字节码对象
        Class aClass = ReflectDemo.class;
        // 获取类加载器对象
        ClassLoader classLoader = aClass.getClassLoader();
        // 加载配置文件,返回字节流对象
        InputStream resourceAsStream = classLoader.getResourceAsStream(&quot;pro.properties&quot;);

        // 读取配置文件
        // 创建Properties对象
        Properties properties = new Properties();
        properties.load(resourceAsStream);

        // 反射的使用
        Object className = properties.getProperty(&quot;className&quot;);
        Object methodName = properties.getProperty(&quot;methodName&quot;);
        // 使用反射创建对象
        Class aClass1 = Class.forName((String) className);
        Constructor constructor = aClass1.getConstructor();
        Object obj = constructor.newInstance();
        // 利用反射获取方法
        Method method = aClass1.getMethod((String) methodName);
        // 使用反射执行方法
        method.invoke(obj);

    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/07/30/Java学习笔记/01_Java如何运行的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/07/30/Java学习笔记/01_Java如何运行的/" itemprop="url">Java是怎么运行的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T18:40:21+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java为什么要在虚拟机中运行"><a href="#Java为什么要在虚拟机中运行" class="headerlink" title="Java为什么要在虚拟机中运行"></a>Java为什么要在虚拟机中运行</h2><ol>
<li>简单的来说,Java作为一门高级程序语言,语法复杂,抽象度高,不能直接翻译为机器码在机器上运行,所以设计者就设计了虚拟机,通过编译器将Java程序转换成虚拟机所能识别的指令码,也就是Java字节码,Java字节码会被虚拟机翻译为可以被机器识别的机器码.这也实现了Java的跨平台</li>
<li>虚拟机的第二个好处就是带来了一个托管环境,托管环境能够代替我们处理代码中冗余并且容易出错的部分,比如自动内存管理,垃圾回收. 还有诸如数组越界、动态类型、安全权限等等动态监测.</li>
</ol>
<h2 id="Java如何在虚拟机中运行的"><a href="#Java如何在虚拟机中运行的" class="headerlink" title="Java如何在虚拟机中运行的"></a>Java如何在虚拟机中运行的</h2><ol>
<li>从虚拟机角度来看,执行Java代码首先需要将它编译而成的class文件加载到虚拟机中.加载后的Java类会被存放与方法区(Method Area)中,运行时,虚拟机执行方法区内的代码</li>
</ol>
<h4 id="Java虚拟机如何存储运行时的数据"><a href="#Java虚拟机如何存储运行时的数据" class="headerlink" title="Java虚拟机如何存储运行时的数据"></a>Java虚拟机如何存储运行时的数据</h4><p>Java虚拟机在内存中划分出堆和栈来存储运行时数据.并且将栈细分为面向Java方法的Java方法栈,面向本地方法的本地方法栈,以及存放各个线程执行位置的PC寄存器.</p>
<p>运行的过程中,每当调用一个方法,Java虚拟机会在当前线程的Java方法栈中生成一个栈帧,存放局部变量以及字节码操作数.这个栈帧大小提前计算好,而且Java虚拟机不要求栈帧在内存空间中连续分步.退出执行方法时,Java虚拟机会弹出当前线程的当前栈帧,并舍弃.</p>
<p>前面说到Java字节码会被虚拟机翻译成机器码,那是如何翻译的呢?有两种形式:第一种是解释执行,也就是逐条将字节码翻译成机器码并执行,优势是无需等待编译.第二种是即时编译(JIT),也就是将一个方法中包含的所有字节码编译成机器码后再执行,优势在于实际运行速度很快.而我们常用的HotSpot虚拟机默认采用混合模式,综合了解释执行和即时编译两者的优点,先解释执行字节码,而后将反复执行的热点代码,以方法为单位进行即时编译.</p>
<h2 id="运行效率如何"><a href="#运行效率如何" class="headerlink" title="运行效率如何"></a>运行效率如何</h2><p>前面说的极是编译就是用来提升性能以及峰值性能,它是建立在程序符合二八定律的假设上,也就是百分之二十的代码占据百分之八十的计算资源.</p>
<p>如何理解?对于占据大部分不常用的代码,无需耗费时间将其编译成机器码,而是采取解释执行的方式运行;另一方面,对于占据小部分的热点代码,将其编译器成机器码,提高运行速度.</p>
<p>HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是<br>Java 10 正式引入的实验性即时编译器,InfoQ上有个介绍(<a href="http://www.infoq.com/cn/articles/Graal-Java-JIT-Compiler?utm_source=articles_about_java&amp;utm_medium=link&amp;utm_campaign=java),有兴趣的可以了解下" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/Graal-Java-JIT-Compiler?utm_source=articles_about_java&amp;utm_medium=link&amp;utm_campaign=java),有兴趣的可以了解下</a>.</p>
<p>C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</p>
<p>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。</p>
<p>Java7开始,HotSpot默认采取分层编译:热点方法首先被C1编译,而后热点方法中的热点会进一步被C2编译.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，<br>代替我们处理部分冗长而且容易出错的事务，例如内存管理。</p>
<p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机<br>中运行。</p>
<p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。</p>
<p>它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。</p>
<p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/07/30/深入理解Java虚拟机/01_Java如何运行的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/07/30/深入理解Java虚拟机/01_Java如何运行的/" itemprop="url">Java是怎么运行的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T18:40:21+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/WangZhi.github.io/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java为什么要在虚拟机中运行"><a href="#Java为什么要在虚拟机中运行" class="headerlink" title="Java为什么要在虚拟机中运行"></a>Java为什么要在虚拟机中运行</h2><ol>
<li>简单的来说,Java作为一门高级程序语言,语法复杂,抽象度高,不能直接翻译为机器码在机器上运行,所以设计者就设计了虚拟机,通过编译器将Java程序转换成虚拟机所能识别的指令码,也就是Java字节码,Java字节码会被虚拟机翻译为可以被机器识别的机器码.这也实现了Java的跨平台</li>
<li>虚拟机的第二个好处就是带来了一个托管环境,托管环境能够代替我们处理代码中冗余并且容易出错的部分,比如自动内存管理,垃圾回收. 还有诸如数组越界、动态类型、安全权限等等动态监测.</li>
</ol>
<h2 id="Java如何在虚拟机中运行的"><a href="#Java如何在虚拟机中运行的" class="headerlink" title="Java如何在虚拟机中运行的"></a>Java如何在虚拟机中运行的</h2><ol>
<li>从虚拟机角度来看,执行Java代码首先需要将它编译而成的class文件加载到虚拟机中.加载后的Java类会被存放与方法区(Method Area)中,运行时,虚拟机执行方法区内的代码</li>
</ol>
<h4 id="Java虚拟机如何存储运行时的数据"><a href="#Java虚拟机如何存储运行时的数据" class="headerlink" title="Java虚拟机如何存储运行时的数据"></a>Java虚拟机如何存储运行时的数据</h4><p>Java虚拟机在内存中划分出堆和栈来存储运行时数据.并且将栈细分为面向Java方法的Java方法栈,面向本地方法的本地方法栈,以及存放各个线程执行位置的PC寄存器.</p>
<p>运行的过程中,每当调用一个方法,Java虚拟机会在当前线程的Java方法栈中生成一个栈帧,存放局部变量以及字节码操作数.这个栈帧大小提前计算好,而且Java虚拟机不要求栈帧在内存空间中连续分步.退出执行方法时,Java虚拟机会弹出当前线程的当前栈帧,并舍弃.</p>
<p>前面说到Java字节码会被虚拟机翻译成机器码,那是如何翻译的呢?有两种形式:第一种是解释执行,也就是逐条将字节码翻译成机器码并执行,优势是无需等待编译.第二种是即时编译(JIT),也就是将一个方法中包含的所有字节码编译成机器码后再执行,优势在于实际运行速度很快.而我们常用的HotSpot虚拟机默认采用混合模式,综合了解释执行和即时编译两者的优点,先解释执行字节码,而后将反复执行的热点代码,以方法为单位进行即时编译.</p>
<h2 id="运行效率如何"><a href="#运行效率如何" class="headerlink" title="运行效率如何"></a>运行效率如何</h2><p>前面说的极是编译就是用来提升性能以及峰值性能,它是建立在程序符合二八定律的假设上,也就是百分之二十的代码占据百分之八十的计算资源.</p>
<p>如何理解?对于占据大部分不常用的代码,无需耗费时间将其编译成机器码,而是采取解释执行的方式运行;另一方面,对于占据小部分的热点代码,将其编译器成机器码,提高运行速度.</p>
<p>HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是<br>Java 10 正式引入的实验性即时编译器,InfoQ上有个介绍(<a href="http://www.infoq.com/cn/articles/Graal-Java-JIT-Compiler?utm_source=articles_about_java&amp;utm_medium=link&amp;utm_campaign=java),有兴趣的可以了解下" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/Graal-Java-JIT-Compiler?utm_source=articles_about_java&amp;utm_medium=link&amp;utm_campaign=java),有兴趣的可以了解下</a>.</p>
<p>C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</p>
<p>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。</p>
<p>Java7开始,HotSpot默认采取分层编译:热点方法首先被C1编译,而后热点方法中的热点会进一步被C2编译.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，<br>代替我们处理部分冗长而且容易出错的事务，例如内存管理。</p>
<p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机<br>中运行。</p>
<p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。</p>
<p>它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。</p>
<p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://misswanglove.github.io/WangZhi.github.io/WangZhi.github.io/2018/07/28/Java学习笔记/day13-Stream流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王智家园">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/WangZhi.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IT小白进阶">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/WangZhi.github.io/2018/07/28/Java学习笔记/day13-Stream流/" itemprop="url">day13-Stream流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T20:04:58+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stream流的初步学习"><a href="#Stream流的初步学习" class="headerlink" title="Stream流的初步学习"></a>Stream流的初步学习</h1><p><strong><em>初次学习Stream流的学习笔记,学习之前先了解一下函数式接口</em></strong></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>API是一个程序向使用者提供的一些方法,通过这些方法就能实现某些功能.所以对于流API来<br>说,重点是怎么理解”流”这个概念,所谓的流:就是数据的渠道,所以,流代表的是一个对象的<br>序列.它和Java I/O类里使用的”流”不同.虽然在概念上与java.util.stream中定义的流是类<br>似的,但它们是不同的.流API中的流是描述某个流类型的对象.</p>
<p>流API中的流操作的数据源,是数组或者是集合.它本身是不存储数据的,只是移动数据,在移动<br>过程中可能会对数据进行过滤,排序或者其它操作.但是,一般情况下(绝大数情况下),流操作<br>本身不会修改数据源.比如,对流排序不会修改数据源的顺序.相反,它会创建一个新的流,其<br>中包含排序后的结果.</p>
<blockquote>
<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何<br>  元素（或其地址值）。</p>
</blockquote>
<p>Stream（流）是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组 等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent<br>style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭<br>代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结<br>果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以<br>像链条一样排列，变成一个管道。</p>
<h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>java.util.stream.Stream<t> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</t></p>
<p>获取一个流非常简单，有以下几种常用的方式：</p>
<ul>
<li>所有的Collection 集合都可以通过stream 默认方法获取流；<ul>
<li>default Stream<e> stream()  </e></li>
</ul>
</li>
<li>Stream 接口的静态方法of 可以获取数组对应的流。<ul>
<li>static <t> Stream<t> of(T… values)<blockquote>
<p>可以看出,Stream流是与容器相关的.</p>
</blockquote>
</t></t></li>
</ul>
</li>
</ul>
<p>下面例子演示如何获取Stream流:</p>
<pre><code>package com.wzlove.stream.demo2;

import java.util.*;
import java.util.stream.Stream;

/**
 * @创建人 王智
 * @创建时间 2018/7/28
 * @描述 演示获取Stream流
 */
public class ConvertStream {

    public static void main(String[] args) {
        // 单列集合根据Collection的stream方法获取流
        // 数组集合
        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
        Stream&lt;String&gt; stream1 = arrayList.stream();
        // set集合
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        Stream&lt;String&gt; stream2 = set.stream();
        // Map集合不能直接转化为Stream流,但是可以先将Map集合转化为Set集合
        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        // map集合转化为Set集合再转化为Stream流
        Stream&lt;String&gt; stream3 = map.keySet().stream();
        Stream&lt;String&gt; stream4 = map.values().stream();
        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = map.entrySet().stream();

        // 使用第二种方式获取Stream流
        // 传递数组
        Stream&lt;int[]&gt; stream6 = Stream.of(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9});
        // 传入可变参数
        Stream&lt;Integer&gt; stream7 = Stream.of(1, 2, 3, 4, 5, 6);
    }
}
</code></pre><h3 id="Stream的常用方法"><a href="#Stream的常用方法" class="headerlink" title="Stream的常用方法"></a>Stream的常用方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>
<ul>
<li>延迟方法：返回值类型仍然是Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方<br>法均为延迟方法。）</li>
<li>终结方法：返回值类型不再是Stream 接口自身类型的方法，因此不再支持类似StringBuilder 那样的链式调<br>用。本小节中，终结方法包括count 和forEach 方法。</li>
</ul>
<blockquote>
<p>注意 : Stream流只能被使用一次,再次使用会抛出异常,说流已经关闭.</p>
</blockquote>
<h4 id="逐一处理"><a href="#逐一处理" class="headerlink" title="逐一处理"></a>逐一处理</h4><p>方法不一一演示,最后统一演示:</p>
<ul>
<li>void forEach(Consumer&lt;? super T&gt; action);该方法接收一个Consumer 接口函数，会将每一个流元素交给该函数进行处理。</li>
</ul>
<blockquote>
<p>终结方法,遍历之后就不能再调用Stream流中的其他方法</p>
</blockquote>
<h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><ul>
<li>Stream<t> filter(Predicate&lt;? super T&gt; predicate);<br>  该接口接收一个Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</t></li>
</ul>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ul>
<li><r> Stream<r> map(Function&lt;? super T, ? extends R&gt; mapper);<br>  该接口需要一个Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</r></r></li>
</ul>
<h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><ul>
<li>long count();该方法返回一个long值代表元素个数（不再像旧集合那样是int值）</li>
</ul>
<blockquote>
<p>也是一个终结方法</p>
</blockquote>
<h4 id="取用前几个"><a href="#取用前几个" class="headerlink" title="取用前几个"></a>取用前几个</h4><ul>
<li>Stream<t> limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。</t></li>
</ul>
<h4 id="跳过前几个"><a href="#跳过前几个" class="headerlink" title="跳过前几个"></a>跳过前几个</h4><ul>
<li>Stream<t> skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</t></li>
</ul>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul>
<li>static <t> Stream<t> concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) :<br>  如果有两个流，希望合并成为一个流，那么可以使用Stream 接口的静态方法concat</t></t></li>
</ul>
<blockquote>
<p>备注：这是一个静态方法，与java.lang.String 当中的concat 方法是不同的。</p>
</blockquote>
<p>演示前几个常用方法:</p>
<pre><code>package com.wzlove.stream.demo2;

import java.util.ArrayList;

/**
 * @创建人 王智
 * @创建时间 2018/7/28
 * @描述 测试Stream流的常用方法
 */
public class StreamUsuallyMethod {

    public static void main(String[] args) {
        // 准备数据
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(5);
        arrayList.add(3);
        arrayList.add(9);
        arrayList.add(1);
        arrayList.add(4);
        arrayList.add(2);
        arrayList.add(3);
        arrayList.add(6);
        arrayList.add(8);
        arrayList.add(7);
        // 测试Stream的forEach方法
        System.out.print(&quot;forEach方法的测试 : &quot;);
        arrayList.stream().forEach(elem -&gt; System.out.print(elem + &quot;  &quot;));
        System.out.println();

        // 测试Filter方法
        // 获取集合中大于5的数字
        System.out.print(&quot;获取集合中大于5的数字 : &quot;);
        arrayList.stream().filter(elem -&gt; elem &gt; 5).forEach(elem -&gt; System.out.print(elem + &quot;   &quot;));
        System.out.println();
        // 获取集合中大于2小于7的数字
        System.out.print(&quot;获取集合中大于2小于7的数字 : &quot;);
        arrayList.stream().filter(elem -&gt; elem &gt; 2).filter(elem -&gt; elem &lt; 7).forEach(elem -&gt; System.out.print(elem + &quot;   &quot;));
        System.out.println();


        // 测试Map方法
        // 将集合转化为String集合
        System.out.print(&quot;map方法将int转化为String : &quot;);
        arrayList.stream().map(elem -&gt; String.valueOf(elem)).forEach(elem -&gt; System.out.print(elem + &quot;   &quot;));
        System.out.println();
    }
}
</code></pre><p>举个例子,使用所有的常用方法:</p>
<pre><code>package com.wzlove.stream.demo2;

import java.util.ArrayList;
import java.util.stream.Stream;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述
 *  1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。
 * 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。
 * 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。
 * 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。
 * 5. 将两个队伍合并为一个队伍；存储到一个新集合中。
 * 6. 根据姓名创建Person 对象；存储到一个新集合中。
 * 7. 打印整个队伍的Person对象信息。
 */
public class StreamDemo {

    public static void main(String[] args) {

        //第一支队伍
        ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);
        //第二支队伍
        ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);
        /*
         *  1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。
         * 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。
         * 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。
         * 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。
         * 5. 将两个队伍合并为一个队伍；存储到一个新集合中。
         * 6. 根据姓名创建Person 对象；存储到一个新集合中。
         * 7. 打印整个队伍的Person对象信息。
         */
        // 直接使用Stream流来完成
        Stream.concat(
                one.stream().filter(elem -&gt; elem.length() == 3).limit(3),
                two.stream().filter(elem -&gt; elem.startsWith(&quot;张&quot;)).skip(2))
                .map(elem -&gt; new Person(elem))
                .forEach(elem -&gt; System.out.println(elem));
    }
}
</code></pre><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><strong><em>很少使用</em></strong></p>
<p>:: 写法就是方法的引用,它的出现是为了简化Lambda的写法.</p>
<p>System.out 对象中有一个重载的println(String) 方法恰好就是我们所需要的。那么对于<br>printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法： s -&gt; System.out.println(s);</li>
<li>方法引用写法： System.out::println</li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println 方法去处理。</p>
<p>第二种等效写法的语义是指：直接让System.out 中的println 方法来取代Lambda。两种写法的执行效果完全一<br>样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<blockquote>
<p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
</blockquote>
<p><strong>类型有</strong><br>这些很少用,是要能看懂就行</p>
<ul>
<li>通过对象名引用成员方法(demo1)</li>
</ul>
<pre><code>package com.wzlove.method.demo1;
/*
    定义一个打印的函数式接口
 */
@FunctionalInterface
public interface Printable {
    //定义字符串的抽象方法
    void print(String s);
}

package com.wzlove.method.demo1;

public class MethodRerObject {
    //定义一个成员方法,传递字符串,把字符串按照大写输出
    public void printUpperCaseString(String str){
        System.out.println(str.toUpperCase());
    }
}

package com.wzlove.method.demo1;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述 使用方法引用简化Lambda表达式,对象调用方法
 */
public class Demo1 {

    public static void printString(Printable printable){
        printable.print(&quot;java&quot;);
    }

    public static void main(String[] args) {

        // 简化前的写法
        printString(s-&gt;{
            // 创建对象
            MethodRerObject methodRerObject = new MethodRerObject();
            // 调用方法
            methodRerObject.printUpperCaseString(s);
        });
        // 简化后的写法,对象调用方法
        // 前提是对象存在,方法存在
        printString(new MethodRerObject()::printUpperCaseString);
    }
}
</code></pre><ul>
<li>通过类名称引用静态方法(demo2)</li>
</ul>
<pre><code>package com.wzlove.method.demo2;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述 计算绝对值的接口
 */
@FunctionalInterface
public interface Calcable {

    int intAbs(int num);
}

package com.wzlove.method.demo2;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述
 */
public class Demo2 {

    public static int methodAds(int num, Calcable calcable){
        return calcable.intAbs(num);
    }

    public static void main(String[] args) {
        // Lambda的写法
        int num1 = methodAds(-100,num-&gt;Math.abs(num));
        System.out.println(num1);
        // 简化Lambda的写法
        // 前提是类存在,静态方法存在
        int result = methodAds(-100,Math::abs);
        System.out.println(result);
    }
}
</code></pre><ul>
<li>通过super引用成员方法</li>
<li>通过this引用成员方法</li>
<li>类的构造器的使用(demo3)</li>
</ul>
<pre><code>package com.wzlove.method.demo3;

public class Person {
    private String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.wzlove.method.demo3;
/*
    定义一个创建Person对象的函数式接口
 */
@FunctionalInterface
public interface PersonBuilder {
    //定义一个方法,根据传递的姓名,创建Person对象返回
    Person builderPerson(String name);
}

package com.wzlove.method.demo3;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述
 */
public class Demo3 {

    public static void buildPerson(String name, PersonBuilder pb){

        Person person = pb.builderPerson(name);
        System.out.println(person.getName());

    }

    public static void main(String[] args) {

        buildPerson(&quot;杨紫&quot;,(name)-&gt;{
            return new Person(name);
        });
        // 方法引用
        // 有参构造
        buildPerson(&quot;迪丽热巴&quot;,Person::new);
    }

}
</code></pre><ul>
<li>数组的构造器的引用(demo4)</li>
</ul>
<pre><code>package com.wzlove.method.demo4;
/*
    定义一个创建数组的函数式接口
 */
@FunctionalInterface
public interface ArrayBuilder {
    //定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组
    int[] builderArray(int length);
}

package com.wzlove.method.demo4;

/**
 * @author 王智
 * @date 2018/7/28
 * @描述
 */
public class Demo4 {

    public static int[] builderArr(int length, ArrayBuilder ab){

        return ab.builderArray(length);

    }

    public static void main(String[] args) {
        int[] arr1 = builderArr(5,length-&gt;new int[length]);
        // 创建数组
        int[] arr = builderArr(5,int[] :: new );
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/WangZhi.github.io/page/2/">2</a><a class="page-number" href="/WangZhi.github.io/page/3/">3</a><a class="extend next" rel="next" href="/WangZhi.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王智家园</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/WangZhi.github.io/archives">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/WangZhi.github.io/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王智家园</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/WangZhi.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/WangZhi.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/WangZhi.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/WangZhi.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
